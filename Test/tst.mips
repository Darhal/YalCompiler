.data
	div_by0: .asciiz "[RUNTIME ERROR]:SEMANTICS: Division by zero is forbidden.\n"
	out_of_bound: .asciiz "[RUNTIME ERROR]:SEMANTICS: Array index is out of bound (or index is negative).\n"
	true_str: .asciiz "vrai\n"
	false_str: .asciiz "faux\n"
.text

main:
	# Begin stackframe:
	move $s7, $sp
	# Allocate for the declared variables:
	addi $sp, $sp, -4

	# Calculating the size of the array 'test_array' (size in $v0): 
	# Integer Constant '25':
	li $v0, 25
	move $a0, $v0
	jal allocate_array
	sw $v0, 0($s7)

	# Integer Constant '1':
	li $v0, 1

	# Assignement for the variable 'test_array':

	# Get adress of the variable 'test_array':
	li $t2, 0
	jal search_var
	move $t3, $v0

	# Integer Constant '0':
	li $v0, 0
	lw $v0, 0($t1)
	move $t1, $t3
	jal get_arr_element_address
	sw $t3, ($v0)

	# Integer Constant '2':
	li $v0, 2

	# Assignement for the variable 'test_array':

	# Get adress of the variable 'test_array':
	li $t2, 0
	jal search_var
	move $t3, $v0

	# Integer Constant '1':
	li $v0, 1
	lw $v0, 0($t1)
	move $t1, $t3
	jal get_arr_element_address
	sw $t3, ($v0)

	# Integer Constant '3':
	li $v0, 3

	# Assignement for the variable 'test_array':

	# Get adress of the variable 'test_array':
	li $t2, 0
	jal search_var
	move $t3, $v0

	# Integer Constant '2':
	li $v0, 2
	lw $v0, 0($t1)
	move $t1, $t3
	jal get_arr_element_address
	sw $t3, ($v0)

	# Integer Constant '0':
	li $v0, 0

	# Get the address of the array 'test_array':
	li $t2, 0
	jal search_var
	move $t1, $v0
	lw $v0, 0($s7)
	jal get_arr_element_value

	# Call write sys call:
	move $a0, $v0
	li $v0, 1
	syscall
	# Return to line:
	li $v0, 11 	# Syscall code for printing one char
	li $a0, '\n' 	# print new line char
	syscall

	# Integer Constant '1':
	li $v0, 1

	# Get the address of the array 'test_array':
	li $t2, 0
	jal search_var
	move $t1, $v0
	lw $v0, 0($s7)
	jal get_arr_element_value

	# Call write sys call:
	move $a0, $v0
	li $v0, 1
	syscall
	# Return to line:
	li $v0, 11 	# Syscall code for printing one char
	li $a0, '\n' 	# print new line char
	syscall

	# Integer Constant '2':
	li $v0, 2

	# Get the address of the array 'test_array':
	li $t2, 0
	jal search_var
	move $t1, $v0
	lw $v0, 0($s7)
	jal get_arr_element_value

	# Call write sys call:
	move $a0, $v0
	li $v0, 1
	syscall
	# Return to line:
	li $v0, 11 	# Syscall code for printing one char
	li $a0, '\n' 	# print new line char
	syscall

	# Handle program exit
exit:
	li $v0, 10
	syscall

	 # Handle RUNTIME errors
div_by_zero:
	la $a0, div_by0
	li $v0, 4
	syscall
	j exit

	# Sub routine to find variables outside of the local scope:
	# $t1: temp base local | $t2: wanted bloc id | $s0: temp bloc id
search_var:
	move $t1, $s7
	search_loop:
	lw $s0, 4($t1)
	sub $s0, $s0, $t2
	beqz $s0, search_loop_end
	lw $t1, 8($t1)
	j search_loop
search_loop_end:
	jr $ra	#Resume normal execution

	# Allocate array the array size should be in a0, address is in $v0
	# returned address will be in a0:
	allocate_array:
	# multiply a0 by 4:
	li $t4, 4
	multu $a0, $t4
	mflo $a0
	li $t4, 4
	li $v0, 9 	# sbrk syscall
	syscall
 	# Issue the syscall
	# Initialize the array
	sw $a0, 0($v0)
	jr $ra 	#Resume normal execution

	# Get value from an array index should be in $t1, table address is in $v0, value is returned in $v0
get_arr_element_value:
	# multiply a0 by 4:
	li $t4, 4
	multu $t1, $t4
	mflo $t1
	lw $t2, 0($v0) 	# Get the size of the array
	sub $t2, $t2, $t1
	blez $t2, print_bound_err
 # Branch on less than or equal to zero (if size - index <= 0) then print error and exit
	addi $v0, $v0, 1 	# Skip first index it have the size
	add $v0, $v0, $t1 	# $v0 now have the exact address of the element we are searching for
	lw $v0, ($v0)	 # Get the value in the address of $v0 into $v0 register and then return
	jr $ra 	#Resume normal execution

	# Get address from an array. index should be in $t1, table address is in $v0, element address is returned in $v0
get_arr_element_address:
	# multiply a0 by 4:
	li $t4, 4
	multu $t1, $t4
	mflo $t1
	lw $t2, 0($v0) 	# Get the size of the array
	sub $t2, $t2, $t1
	blez $t2, print_bound_err
 # Branch on less than or equal to zero (if size - index <= 0) then print error and exit
	addi $v0, $v0, 1 	# Skip first index it have the size
	add $v0, $v0, $t1 	# $v0 now have the exact address of the element we are searching for
	jr $ra 	#Resume normal execution
print_bound_err:
	la $a0, out_of_bound
	li $v0, 4
	syscall
	j exit

	# Declaration of function: array_test_p1
array_test_p1:
	# Pushing in the function environments (Creating the stack frame)
	# Return address:
	sw $ra, -0($sp)
	# Dynamic linking:
	sw $s7, -4($sp)
	# No bloc:
	li $t8, 1
	sw $t8, -8($sp)
	# Reserve the space for variables: 
	addi $sp, $sp, -12
	move $s7, $sp
	addi $sp, $sp, -4
	# Function instructions 

	# Integer Constant '0':
	li $v0, 0
	j array_test_p1_fin
	# End of the function routine :
array_test_p1_fin:
	# Popping out the function environments (Popping the stack frame)
	addi $sp, $sp, 20
	lw $ra, -4($sp)
	lw $s7, -8($sp)
	jr $ra


