.data
	div_by0: .asciiz "[RUNTIME ERROR]: Division by zero is forbidden.\n"
	true_str: .asciiz "vrai\n"
	false_str: .asciiz "faux\n"
.text

main:
	# Begin stackframe:
	move $s7, $sp
	# Allocate for the declared variables:
	addi $sp, $sp, -12

	# Integer Constant '4':
	li $v0, 4

	# Assignement for the variable 'a':

	# Get adress of the variable 'a':
	li $t2, 0
	jal search_var
	sw $v0, 0($t1)

	# Integer Constant '5':
	li $v0, 5

	# Assignement for the variable 'b':

	# Get adress of the variable 'b':
	li $t2, 0
	jal search_var
	sw $v0, -4($t1)

	# Get value of the variable 'a':
	li $t2, 0
	jal search_var
	lw $v0, 0($t1)
	sw $v0, -0($sp)
	addi $sp, $sp, -4

	jal TEST_p1

	# Assignement for the variable 'c':

	# Get adress of the variable 'c':
	li $t2, 0
	jal search_var
	sw $v0, -8($t1)

	# Get value of the variable 'c':
	li $t2, 0
	jal search_var
	lw $v0, -8($t1)

	# Call write sys call:
	move $a0, $v0
	li $v0, 1
	syscall
	# Return to line:
	li $v0, 11 	# Syscall code for printing one char
	li $a0, '\n' 	# print new line char
	syscall

	# Handle program exit
exit:
	li $v0, 10
	syscall

	 # Handle RUNTIME errors
div_by_zero:
	la $a0, div_by0
	li $v0, 4
	syscall
	j exit
	# Sub routine to find variables outside of the local scope:
	# $t1: temp base local | $t2: wanted bloc id | $s0: temp bloc id
search_var:
	move $t1, $s7
	search_loop:
	lw $s0, 4($t1)
	sub $s0, $s0, $t2
	beqz $s0, search_loop_end
	lw $t1, 8($t1)
	j search_loop
search_loop_end:
	jr $ra	#Resume normal execution

	# Declaration of function: a_p2
a_p2:
	# Pushing in the function environments (Creating the stack frame)
	# Return address:
	sw $ra, -0($sp)
	# Dynamic linking:
	sw $s7, -4($sp)
	# No bloc:
	li $t8, 1
	sw $t8, -8($sp)
	# Reserve the space for variables: 
	addi $sp, $sp, -12
	move $s7, $sp
	addi $sp, $sp, -12
	# Function instructions 

	# Reads an integer: 
	li $v0, 5
	syscall

	# Get adress of the variable 'a':
	li $t2, 1
	jal search_var
	sw $v0, 0($t1)

	# Reads an integer: 
	li $v0, 5
	syscall

	# Get adress of the variable 'b':
	li $t2, 1
	jal search_var
	sw $v0, -4($t1)

	# Reads an integer: 
	li $v0, 5
	syscall

	# Get adress of the variable 'd':
	li $t2, 1
	jal search_var
	sw $v0, -8($t1)

	# Get value of the variable 'a':
	li $t2, 1
	jal search_var
	lw $v0, 0($t1)

	# Call write sys call:
	move $a0, $v0
	li $v0, 1
	syscall
	# Return to line:
	li $v0, 11 	# Syscall code for printing one char
	li $a0, '\n' 	# print new line char
	syscall

	# Get value of the variable 'b':
	li $t2, 1
	jal search_var
	lw $v0, -4($t1)

	# Call write sys call:
	move $a0, $v0
	li $v0, 1
	syscall
	# Return to line:
	li $v0, 11 	# Syscall code for printing one char
	li $a0, '\n' 	# print new line char
	syscall

	# Get value of the variable 'd':
	li $t2, 1
	jal search_var
	lw $v0, -8($t1)

	# Call write sys call:
	move $a0, $v0
	li $v0, 1
	syscall
	# Return to line:
	li $v0, 11 	# Syscall code for printing one char
	li $a0, '\n' 	# print new line char
	syscall

	# Get value of the variable 'x':
	li $t2, 1
	jal search_var
	lw $v0, 20($t1)

	# Call write sys call:
	move $a0, $v0
	li $v0, 1
	syscall
	# Return to line:
	li $v0, 11 	# Syscall code for printing one char
	li $a0, '\n' 	# print new line char
	syscall

	# Get value of the variable 'y':
	li $t2, 1
	jal search_var
	lw $v0, 16($t1)

	# Call write sys call:
	move $a0, $v0
	li $v0, 1
	syscall
	# Return to line:
	li $v0, 11 	# Syscall code for printing one char
	li $a0, '\n' 	# print new line char
	syscall

	# Get value of the variable 'a':
	li $t2, 1
	jal search_var
	lw $v0, 0($t1)
	addi $sp, $sp, -4
	sw $v0, 4($sp)

	# Get value of the variable 'b':
	li $t2, 1
	jal search_var
	lw $v0, -4($t1)
	lw $t8, 4($sp)
	addi $sp, $sp, 4
	# Addition:
	add $v0, $t8, $v0
	j a_p2_fin
	# End of the function routine :
a_p2_fin:
	# Popping out the function environments (Popping the stack frame)
	addi $sp, $sp, 32
	lw $ra, -8($sp)
	lw $s7, -12($sp)
	jr $ra


